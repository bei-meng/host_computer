    consti row_bank_start_c, 3
    consti row_bank_end_c, 4
    consti col_bank_start_c, 3
    consti col_bank_end_c, 4

    consti count_max_c, 128
    consti pq_c, 0

    consti row_index_din_ram_s_c, 0
    consti row_index_din_ram_e_c, 2

    consti col_index_din_ram_s_c, 4
    consti col_index_din_ram_e_c, 6
start:
    addi row_bank_start, zero, row_bank_start_c                            # 起始读的行bank号
    addi row_bank_end, zero, row_bank_end_c                              # 截止读的行bank号
    addi col_bank_start, zero, col_bank_start_c                            # 起始读的列bank号
    addi col_bank_end, zero, col_bank_end_c                              # 截止读的列bank号

    addi shift_one, zero, 1                                 # 用于后面左移掩码（一位）
    addi shift_four, zero, 4                                # 用于后面左移掩码（四位）
    addi four, zero, 4                                      # 存4

    addi count, zero, 0                                     # 初始化计数器
    addi count_max, zero, count_max_c                               # 设置计数器最大值

    addi pq, zero,pq_c
    # ---------------------------------------------------------------------------------------------------
    addi row_index_start_addr, zero, row_index_din_ram_s_c                  # 初始化寄存器，存放din_ram中的第一个行bank起始读的行index的addr
    addi row_index_end_addr, zero, row_index_din_ram_e_c                    # 初始化寄存器，存放din_ram中的第一个行bank截止读的行index的addr

    addi row_bank_mask, zero, 0x01                          # 初始化行bank掩码地址为0x01（用于后续移位，下同）
    sll row_bank_mask, row_bank_mask, row_bank_start        # row_bank_mask << bank_start
    addi row_bank_count, row_bank_start, 0                  # 初始化行bank计数器（起始行bank号）

loop1:
    load_din_ram row_index_count, row_index_start_addr      # 将当前行bank的起始row index加载进来
    load_din_ram row_end_index, row_index_end_addr          # 将当前行bank的截止row index加载进来
    addi row_index_mask, zero, 0x00000001                   # 初始化行bank内行掩码地址为0x00000001（32行）
    sll row_index_mask, row_index_mask, row_index_count     # row_index_mask << row_index_count

    set_row_bank row_bank_mask, row_index_mask              # 配置行bank

loop2:
    addi col_index_start_addr, zero, col_index_din_ram_s_c                  # 初始化寄存器，存放din_ram中的第一个列bank起始读的列index的addr
    addi col_index_end_addr, zero, col_index_din_ram_e_c                    # 初始化寄存器，存放din_ram中的第一个列bank起始读的列index的addr

    addi col_bank_mask, zero, 0x01                          # 初始化列bank掩码地址为0x01（用于后续移位，下同）
    sll col_bank_mask, col_bank_mask, col_bank_start        # mask << col_bank_start
    addi col_bank_count, col_bank_start, 0                  # 初始化列bank计数器（起始列bank号）

loop3:
    load_din_ram col_index_count, col_index_start_addr      # 将当前列bank的起始col index加载进来
    load_din_ram col_end_index, col_index_end_addr          # 将当前列bank的起始col index加载进来
    addi col_index_mask, zero, 0x00000001                   # 初始化列bank内列掩码地址为0x00000001（32列）
    sll col_index_mask, col_index_mask, col_index_count     # col_index_mask << col_index_count

# ----------------------------------------------------------------------------------------------------计算tia
    bge col_bank_count, four, tia_big4                      # 如果col_bank_count >= 4，跳转到tia_big4
tia_nobig4:
    add tmp_bank, col_bank_count, four                      # tmp_bank, col_bank_count + 4
    jump tia_end
tia_big4:
    sub     tmp_bank, col_bank_count, four                  # tmp_bank, col_bank_count - 4
tia_end:
    sll     tmp_bank, tmp_bank, shift_one                   # tmp_bank, tmp_bank << 1
# ----------------------------------------------------------------------------------------------------计算tia

loop4:
    srl tmp_index, col_index_count, shift_four              # tmp_index, col_index_count >> 4
    add tia, tmp_bank, tmp_index                            # tia, tmp_bank + tmp_index
    #addi tia_mask, zero,1
    #sll tia_mask,tia_mask,tia
    set_col_bank col_bank_mask, col_index_mask              # 配置列bank
    row_read_pulse tia,count,pq
# ----------------------------------------------------------------------------------------------------控制返回的计数器
    addi    count, count, 1                                   # count, count + 1
    bge     count, count_max, return_res                       # 如果count >= 128，跳转到return_res
    jump   jump_return
return_res:
    return_dout count,zero ,pq
    xori    pq, pq, 1                                         # pq, pq xor 1 
    addi    count, zero, 0                                    # count, 0
jump_return:
# ----------------------------------------------------------------------------------------------------控制返回的计数器
    bge col_index_count, col_end_index, end4                # 如果col_index_count >= col_end_index，跳转到end4
    addi col_index_count, col_index_count, 1                # col_index_count, col_index_count + 1
    sll col_index_mask, col_index_mask, shift_one           # col_index_mask << 1
    jump loop4

end4:
    set_col_bank col_bank_mask, zero
    bge col_bank_count, col_bank_end, end3                  # 如果col_bank_count >= col_bank_end，跳转到end3
    addi col_bank_count, col_bank_count, 1                  # col_bank_count, col_bank_count + 1
    sll col_bank_mask, col_bank_mask, shift_one             # col_bank_mask << 1
    addi col_index_start_addr, col_index_start_addr, 1      # 下一个列bank的起始读的列index的地址（加改）
    addi col_index_end_addr, col_index_end_addr, 1          # 下一个列bank的截止读的列index的地址（加改）
    jump loop3

end3:
    bge row_index_count, row_end_index, end2                # 如果row_index_count >= row_end_index，跳转到end2
    addi row_index_count, row_index_count, 1                # row_index_count, row_index_count + 1
    sll row_index_mask, row_index_mask, shift_one           # row_index_mask << 1
    jump loop2

end2:
    set_row_bank row_bank_mask, zero
    bge row_bank_count, row_bank_end, end1                  # 如果row_bank_count >= row_bank_end，跳转到end1
    addi row_bank_count, row_bank_count, 1                  # row_bank_count, row_bank_count + 1
    sll row_bank_mask, row_bank_mask, shift_one             # row_bank_mask << 1
    addi row_index_start_addr, row_index_start_addr, 1      # 下一个行bank的起始读的行index的地址（加改）
    addi row_index_end_addr, row_index_end_addr, 1          # 下一个行bank的截止读的行index的地址（加改）
    jump loop1

end1:
    return_dout count,zero ,pq
    exit              # 结束执行